// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import { Test } from "forge-std/Test.sol";

import { BtcPrism } from "bitcoinprism-evm/src/BtcPrism.sol";
import { Endian } from "bitcoinprism-evm/src/Endian.sol";
import { IBtcPrism } from "bitcoinprism-evm/src/interfaces/IBtcPrism.sol";
import { BtcProof, BtcTxProof, ScriptMismatch } from "bitcoinprism-evm/src/library/BtcProof.sol";
import { BtcScript } from "bitcoinprism-evm/src/library/BtcScript.sol";

import { MandateOutput, MandateOutputEncodingLib } from "../../src/libs/MandateOutputEncodingLib.sol";
import { BitcoinOracle } from "../../src/oracles/bitcoin/BitcoinOracle.sol";

import { MockERC20 } from "../mocks/MockERC20.sol";
import "../oracle/bitcoin/blocksinfo.t.sol";

contract BitcoinOracleHarness is BitcoinOracle {
    constructor(
        address _lightClient,
        address disputedOrderFeeDestination,
        address collateralToken,
        uint64 _collateralMultiplier
    ) payable BitcoinOracle(_lightClient, disputedOrderFeeDestination, collateralToken, _collateralMultiplier) { }

    function getProofPeriod(
        uint256 confirmations
    ) external pure returns (uint256) {
        return _getProofPeriod(confirmations);
    }
}

contract BitcoinOracleTest is Test {
    uint32 maxTimeIncrement = 1 days - 1;

    MockERC20 token;

    BtcPrism btcPrism;
    BitcoinOracleHarness bitcoinOracle;

    uint256 multiplier = 1e10 * 100;

    function setUp() public {
        token = new MockERC20("Mock ERC20", "MOCK", 18);

        btcPrism = new BtcPrism(BLOCK_HEIGHT, BLOCK_HASH, BLOCK_TIME, EXPECTED_TARGET, false);

        bitcoinOracle = new BitcoinOracleHarness(address(btcPrism), address(0), address(token), uint64(multiplier));
    }

    function test_verify_duplicate_filler() public {
        bytes32 orderId = keccak256("orderId");
        address caller = makeAddr("solver");

        // We need to warp to the Bitcoin block.
        vm.warp(BLOCK_TIME);
        bytes32 bitcoinOracleBytes32 = bytes32(uint256(uint160(address(bitcoinOracle))));
        MandateOutput memory output = MandateOutput({
            oracle: bytes32(uint256(uint160(address(this)))),
            settler: bitcoinOracleBytes32,
            token: bytes32(bytes.concat(hex"000000000000000000000000BC000000000000000000000000000000000000", UTXO_TYPE)),
            recipient: bytes32(PHASH),
            amount: SATS_AMOUNT,
            chainId: uint32(block.chainid),
            call: hex"",
            context: hex""
        });

        uint256 collateralAmount = output.amount * multiplier;
        token.mint(caller, collateralAmount * 2);
        vm.prank(caller);
        token.approve(address(bitcoinOracle), collateralAmount * 2);

        bytes32 solver = keccak256("solver");
        vm.prank(caller);
        bitcoinOracle.claim(solver, orderId, output);

        {
            BtcTxProof memory inclusionProof = BtcTxProof({
                blockHeader: BLOCK_HEADER,
                txId: TX_ID,
                txIndex: TX_INDEX,
                txMerkleProof: TX_MERKLE_PROOF,
                rawTx: RAW_TX
            });

            bitcoinOracle.verify(orderId, output, BLOCK_HEIGHT, inclusionProof, TX_OUTPUT_INDEX);
        }
        // Check if the payload has been correctly stored.
        bytes memory payload =
            MandateOutputEncodingLib.encodeFillDescriptionMemory(solver, orderId, uint32(BLOCK_TIME), output);
        bytes[] memory payloads = new bytes[](1);
        payloads[0] = payload;
        bool fillerValid = bitcoinOracle.hasAttested(payloads);
        assertEq(fillerValid, true);

        // Try to overwrite the claim.
        MandateOutput memory duplicateOutput = MandateOutput({
            oracle: bytes32(uint256(uint160(address(this))) + 1),
            settler: bitcoinOracleBytes32,
            token: bytes32(bytes.concat(hex"000000000000000000000000BC000000000000000000000000000000000000", UTXO_TYPE)),
            recipient: bytes32(PHASH),
            amount: SATS_AMOUNT,
            chainId: uint32(block.chainid),
            call: hex"",
            context: hex""
        });
        bytes32 duplicateSolver = keccak256("duplicateSolver");

        vm.prank(caller);
        bitcoinOracle.claim(duplicateSolver, orderId, duplicateOutput);

        {
            BtcTxProof memory inclusionProof = BtcTxProof({
                blockHeader: BLOCK_HEADER,
                txId: TX_ID,
                txIndex: TX_INDEX,
                txMerkleProof: TX_MERKLE_PROOF,
                rawTx: RAW_TX
            });

            bitcoinOracle.verify(orderId, duplicateOutput, BLOCK_HEIGHT, inclusionProof, TX_OUTPUT_INDEX);
        }

        // Check if the payload has been correctly stored.
        bytes memory duplicatePayload = MandateOutputEncodingLib.encodeFillDescriptionMemory(
            duplicateSolver, orderId, uint32(BLOCK_TIME), duplicateOutput
        );
        bytes[] memory duplicatePayloads = new bytes[](1);
        duplicatePayloads[0] = duplicatePayload;
        bool duplicateFillerValid = bitcoinOracle.hasAttested(duplicatePayloads);
        assertEq(duplicateFillerValid, false);
    }
}
